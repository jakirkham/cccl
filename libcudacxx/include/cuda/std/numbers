//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

#ifndef _CUDA_STD_NUMBERS
#define _CUDA_STD_NUMBERS

#include <cuda/std/detail/__config>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif // no system header

#include <cuda/std/__concepts/concept_macros.h>
#include <cuda/std/__type_traits/enable_if.h>
#include <cuda/std/__type_traits/is_floating_point.h>
#include <cuda/std/version>

#if defined(_LIBCUDACXX_HAS_NVFP16)
#  include <cuda_fp16.h>
#endif // _LIBCUDACXX_HAS_NVFP16
#if defined(_LIBCUDACXX_HAS_NVBF16)
_CCCL_DIAG_PUSH
_CCCL_DIAG_SUPPRESS_CLANG("-Wunused-function")
#  include <cuda_bf16.h>
_CCCL_DIAG_POP
#endif // _LIBCUDACXX_HAS_NVBF16

_LIBCUDACXX_BEGIN_NAMESPACE_STD

namespace numbers
{

template <class _Tp, class = void>
struct __e
{};

template <class _Tp>
struct __e<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 2.718281828459045235360287471352662;
};

template <class _Tp, class = void>
struct __log2e
{};

template <class _Tp>
struct __log2e<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 1.442695040888963407359924681001892;
};

template <class _Tp, class = void>
struct __log10e
{};

template <class _Tp>
struct __log10e<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.434294481903251827651128918916605;
};

template <class _Tp, class = void>
struct __pi
{};

template <class _Tp>
struct __pi<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 3.141592653589793238462643383279502;
};

template <class _Tp, class = void>
struct __inv_pi
{};

template <class _Tp>
struct __inv_pi<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.318309886183790671537767526745028;
};

template <class _Tp, class = void>
struct __inv_sqrtpi
{};

template <class _Tp>
struct __inv_sqrtpi<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.564189583547756286948079451560772;
};

template <class _Tp, class = void>
struct __ln2
{};

template <class _Tp>
struct __ln2<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.693147180559945309417232121458176;
};

template <class _Tp, class = void>
struct __ln10
{};

template <class _Tp>
struct __ln10<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 2.302585092994045684017991454684364;
};

template <class _Tp, class = void>
struct __sqrt2
{};

template <class _Tp>
struct __sqrt2<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 1.414213562373095048801688724209698;
};

template <class _Tp, class = void>
struct __sqrt3
{};

template <class _Tp>
struct __sqrt3<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 1.732050807568877293527446341505872;
};

template <class _Tp, class = void>
struct __inv_sqrt3
{};

template <class _Tp>
struct __inv_sqrt3<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.577350269189625764509148780501957;
};

template <class _Tp, class = void>
struct __egamma
{};

template <class _Tp>
struct __egamma<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 0.577215664901532860606512090082402;
};

template <class _Tp, class = void>
struct __phi
{};

template <class _Tp>
struct __phi<_Tp, enable_if_t<_CCCL_TRAIT(is_floating_point, _Tp)>>
{
  static constexpr _Tp value = 1.618033988749894848204586834365638;
};

#if defined(_LIBCUDACXX_HAS_NVFP16)
template <>
struct __e<__half>
{
  static constexpr __half value{__half_raw{0x4170u}};
};

template <>
struct __log2e<__half>
{
  static constexpr __half value{__half_raw{0x3dc5u}};
};

template <>
struct __log10e<__half>
{
  static constexpr __half value{__half_raw{0x36f3u}};
};

template <>
struct __pi<__half>
{
  static constexpr __half value{__half_raw{0x4248u}};
};

template <>
struct __inv_pi<__half>
{
  static constexpr __half value{__half_raw{0x3518u}};
};

template <>
struct __inv_sqrtpi<__half>
{
  static constexpr __half value{__half_raw{0x3883u}};
};

template <>
struct __ln2<__half>
{
  static constexpr __half value{__half_raw{0x398cu}};
};

template <>
struct __ln10<__half>
{
  static constexpr __half value{__half_raw{0x409bu}};
};

template <>
struct __sqrt2<__half>
{
  static constexpr __half value{__half_raw{0x3da8u}};
};

template <>
struct __sqrt3<__half>
{
  static constexpr __half value{__half_raw{0x3eeeu}};
};

template <>
struct __inv_sqrt3<__half>
{
  static constexpr __half value{__half_raw{0x389eu}};
};

template <>
struct __egamma<__half>
{
  static constexpr __half value{__half_raw{0x389eu}};
};

template <>
struct __phi<__half>
{
  static constexpr __half value{__half_raw{0x3e79u}};
};
#endif // _LIBCUDACXX_HAS_NVFP16

#if defined(_LIBCUDACXX_HAS_NVBF16)
template <>
struct __e<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x402eu}};
};

template <>
struct __log2e<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3fb9u}};
};

template <>
struct __log10e<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3edeu}};
};

template <>
struct __pi<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x4049u}};
};

template <>
struct __inv_pi<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3ea3u}};
};

template <>
struct __inv_sqrtpi<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3f10u}};
};

template <>
struct __ln2<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3f31u}};
};

template <>
struct __ln10<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x4013u}};
};

template <>
struct __sqrt2<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3fb5u}};
};

template <>
struct __sqrt3<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3fdeu}};
};

template <>
struct __inv_sqrt3<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3f14u}};
};

template <>
struct __egamma<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3f14u}};
};

template <>
struct __phi<__nv_bfloat16>
{
  static constexpr __nv_bfloat16 value{__nv_bfloat16_raw{0x3fcfu}};
};
#endif // _LIBCUDACXX_HAS_NVBF16

#if !defined(_CCCL_NO_VARIABLE_TEMPLATES)

template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp e_v = __e<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp log2e_v = __log2e<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp log10e_v = __log10e<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp pi_v = __pi<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp inv_pi_v = __inv_pi<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp inv_sqrtpi_v = __inv_sqrtpi<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp ln2_v = __ln2<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp ln10_v = __ln10<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp sqrt2_v = __sqrt2<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp sqrt3_v = __sqrt3<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp inv_sqrt3_v = __inv_sqrt3<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp egamma_v = __egamma<_Tp>::value;
template <class _Tp>
_CCCL_GLOBAL_CONSTANT _Tp phi_v = __phi<_Tp>::value;

_CCCL_GLOBAL_CONSTANT double e          = e_v<double>;
_CCCL_GLOBAL_CONSTANT double log2e      = log2e_v<double>;
_CCCL_GLOBAL_CONSTANT double log10e     = log10e_v<double>;
_CCCL_GLOBAL_CONSTANT double pi         = pi_v<double>;
_CCCL_GLOBAL_CONSTANT double inv_pi     = inv_pi_v<double>;
_CCCL_GLOBAL_CONSTANT double inv_sqrtpi = inv_sqrtpi_v<double>;
_CCCL_GLOBAL_CONSTANT double ln2        = ln2_v<double>;
_CCCL_GLOBAL_CONSTANT double ln10       = ln10_v<double>;
_CCCL_GLOBAL_CONSTANT double sqrt2      = sqrt2_v<double>;
_CCCL_GLOBAL_CONSTANT double sqrt3      = sqrt3_v<double>;
_CCCL_GLOBAL_CONSTANT double inv_sqrt3  = inv_sqrt3_v<double>;
_CCCL_GLOBAL_CONSTANT double egamma     = egamma_v<double>;
_CCCL_GLOBAL_CONSTANT double phi        = phi_v<double>;

#endif // !_CCCL_NO_VARIABLE_TEMPLATES

} // namespace numbers

_LIBCUDACXX_END_NAMESPACE_STD

#endif // _CUDA_STD_NUMBERS
